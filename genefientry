#!/bin/bash

err() {
  echo "Error: ${1}"
  exit 1
}

usage() {
  cat <<-EOF
  Usage: genefientry -p /dev/sdb1 -x /efi/gentoo/vmlinuz-linux.efi
                -p,--efi-partition              efi partition (required)
                -x,--efi-executable             path to efi executable (required)
                -l,--boot-label                 label or name of the new boot entry
                -m,--microcode                  path to microcode
                -h,--help                       see this menu

  Note: make sure the efi executable and microcode files reside in the efi partition.
EOF
  exit ${1:-1}
}

[[ $# -lt 1 ]] && usage 1

EFIDISKPART=
BOOTLABEL=
EFIEXECPATH=
MICROCODE=

while [[ $# -gt 0 ]]; do
  case $1 in
    -h|--help)
      usage 0
      ;;
    -l|--boot-label)
      BOOTLABEL="${2}"
      shift
      ;;
    -m|--microcode)
      [[ -f "${2}" ]] || err "! ${2} file doesn't exist!"
      MICROCODE="${2}"
      shift
      ;;
    -p|--efi-partition)
      if ! lsblk -no UUID "${2}" >/dev/null 2>&1 ; then
      	err "! ${2} target EFI partition does not exist!"
      fi
      if [[ $(lsblk -no FSTYPE "${2}" 2>/dev/null) != vfat ]] ; then
      	err "! ${2} target partition is not vfat type!"
      fi
      EFIDISKPART="${2}"
      shift
      ;;
    -x|--efi-executable)
      [[ -f "${2}" ]] || err "! ${2} efi executable doesn't exist!"
      [[ ${2##*.} == efi ]] || "! ${2} not an efi executable!"
      EFIEXECPATH="${2}"
      shift
      ;;
    *)
      echo "! one or more invalid arguments!" && usage 1
      ;;
  esac
  shift
done

[[ $(whoami) == root ]] || err "! root permission required!"
[[ -f /etc/fstab ]] || err "/etc/fstab is not found!!!"
[[ -w /etc/fstab ]] || err "/etc/fstab is not writable!!!"

[[ -z ${EFIDISKPART} ]] && err "no efi partition given. see --help"
[[ -z ${EFIEXECPATH} ]] && err "no efi executable given. see --help"

# EFI partition disk id ; for --disk
# /dev/sda1    -> /dev/sda
# /dev/nvme0p1 -> /dev/nvme0
EFIDISKID="$(echo ${EFIDISKPART} | awk -F [0-9]*\$ '{print $1}')"
if [[ $EFIDISKID == /dev/nvme[0-9]*p ]]; then
  EFIDISKID="${EFIDISKID%p}"
fi

# EFI partition no. ; for --part
# /dev/sda1    -> 1
# /dev/nvme0p1 -> 1
EFIPARTID="$(echo ${EFIDISKPART} | grep -Eo [0-9]*\$)"

# label/identifier of the new boot entry ; for --label
if [[ -z $BOOTLABEL ]]; then
  # default to PRETTY_NAME in /etc/os-release
  BOOTLABEL="$(grep "PRETTY_NAME=" /etc/os-release  | awk -F "=" '{print $2}' | tr -d '"' | xargs)"
  [[ -z $BOOTLABEL ]] && err "! unable to determine label of new boot entry! use -l option or see --help"
fi
# don't use names starting with EFI,
# to prevent overwriting system EFI device entries like EFI Network, EFI USB Device etc
if [[ ${BOOTLABEL} == EFI* ]]; then
  echo "! Please use a differnet label that doesn't start with 'EFI'"
  err  "Given boot label may conflict with system EFI entries! Stopping..."
fi

# get efi mount point
efimountpoint="$(lsblk -no MOUNTPOINTS ${EFIDISKPART})"
[[ -z ${efimountpoint} ]] && err "! ${EFIDISKPART} efi parttion is not mounted. please mount the efi partition first."

# efi executable or simply the vmlinuz.efi file path relative to efi mount point
# if efi mount point is /efi and efi executable is /efi/gentoo/vmlinuz-linux.efi
# relative loader path will be "gentoo\vmlinuz-linux.efi" ; --loader
LOADER="$(echo ${EFIEXECPATH##${efimountpoint}} | tr '\/' '\\')"

# --unicode
# an example looks like:
# 	"root=UUID=xxxxx... rootfstype=btrfs
#	 rootflags=subvol=/foo rw resume=/swapfie
# 	 initrd=\EFI\microcode.img initrd=\EFI\initramfs.img"
UNICODE=

# find the root partition entry from /etc/fstab and obtain it's UUID
# root=UUID=xxxx or root=PARTUUID=xxxx
ROOTPART="$(grep ^[^#] /etc/fstab | grep "/ " | awk '{print $1}' )"
if [[ ${ROOTPART} == /dev/* ]]; then
  ROOTUUID="$(lsblk -no UUID "${ROOTPART}" 2>/dev/null)"
else
  ROOTUUID="${ROOTPART}"
fi
if [[ ! -z ${ROOTUUID} ]] ; then
  UNICODE="root=${ROOTUUID}"
else
  err "! unable to find UUID of root partiotion!"
fi
# root filesystem type
# rootfs=xxxxx
ROOTFSTYPE="$(grep ^[^#] /etc/fstab | grep "/ " | awk '{print $3}')"
[[ ! -z $ROOTFSTYPE ]] && UNICODE="${UNICODE} rootfstype=${ROOTFSTYPE}"
# rootflags
# rootflags=xxxxx
ROOTFLAGS="$(grep ^[^#] /etc/fstab | grep "/ " | awk '{print $4}')"
[[ ! -z $ROOTFLAGS ]] && UNICODE="${UNICODE} rootflags=${ROOTFLAGS}"
# make sure to mount root as read-writable
UNICODE="${UNICODE} rw"

# swap
# resume=xxxx
SWAPPART="$(grep ^[^#] /etc/fstab | grep "swap " | awk '{print $1}' )"
if [[ ! -z ${SWAPPART} ]] ; then
  UNICODE="${UNICODE} resume=${SWAPPART}"
fi

# microcode
# initrd=/EFI/microcode.img
if [[ -f ${MICROCODE} ]]; then
  MICROCODE="$(echo ${MICROCODE##${efimountpoint}} | tr '\/' '\\')"
  UNICODE="${UNICODE} initrd=${MICROCODE}"
fi

# initramfs; basically check initramfs file with the
# same kernel version in the efi directory.
# initrd=/EFI/initramfs.img
INITRAMFS="${EFIEXECPATH/%efi/img}"
INITRAMFS="${INITRAMFS/vmlinuz/initramfs}"
if [[ -f ${INITRAMFS} ]] ; then
  INITRAMFS="$(echo ${INITRAMFS##${efimountpoint}} | tr '\/' '\\')"
  UNICODE="${UNICODE} initrd=${INITRAMFS}"
fi

# remove duplicate entries
echo "> Removing duplicate entries..."
for id in $(efibootmgr | grep "${BOOTLABEL}$" | awk '{ print $1 }' | tr -d "*"); do
  efibootmgr -q -b "${id#Boot}" -B 2>/dev/null
done
echo "> Creating new boot entry : ${BOOTLABEL}"

# create new entry
efibootmgr --quiet --create --disk ${EFIDISKID} --part ${EFIPARTID} --label "${BOOTLABEL}" --loader "${LOADER}" --unicode "${UNICODE}" || err "!!! Failed to create new boot entry!"
#   
echo "> Successfully added new boot entry : ${BOOTLABEL}"
echo
efibootmgr
